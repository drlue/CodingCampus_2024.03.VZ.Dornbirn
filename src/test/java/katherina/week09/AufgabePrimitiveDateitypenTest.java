package katherina.week09;

import katherina.week01.day05.AufgabePrimitiveDateitypen;
//Es importiert natürlich die Klasse, die getestet werden soll, um auf die enthaltenen Methoden zugreifen zu können.
import org.junit.jupiter.api.Test;
//Es importiert außerdem Methoden.

import static org.junit.jupiter.api.Assertions.*;

public class AufgabePrimitiveDateitypenTest {
    //Erst einmal die Grundlagen kapieren, ehe ich die Schule teste. Wie geht sowas, wenn es rein um irgendwelche Zahlen geht?
    //Im Prinzip code ich hier den "FakulTest.java" von Gyula nach, um meine Schritte zu kommentieren.

    @Test
    public void faktorial1Test() {
        //"AufgabePrimitiveDateitypen" enthält MEHRERE Methoden. Dies testet nur eine davon. Möchte ich die anderen testen, muss ich eigene Methoden schreiben.
        //Ja, auch dann, wenn die Methoden alle das Gleiche machen ;-).
        // Prepare - ich muss bei dieser konkreten Klasse nichts vorbereiten, aber bei anderen schon.

        // Test
        long l = AufgabePrimitiveDateitypen.faktorial1(7);
        //Hier schreibe ich rein, was getestet werden soll. In diesem Fall: Klasse: AufgabePrimitiveDateitypen. Methode: faktorial1.

        // Restore (Optional)
        // Hier wird nichts überschrieben, also muss ich auch nichts wiederherstellen.

        // Evaluate
        assertEquals(5040, l);
        //Alles tutti.
        //Nun machen wir absichtlich eine falsche Eingabe, um die Ausgabe anzugucken:

        //assertEquals(13, l); - auskommentiert, damit es mir nicht die folgende Ausgabe zerschießt.
      //Über der Konsolenausgabe steht nun in roter Schrift und mit einem gelben Button "Tests faild: 1".
//        Expected :13
//        Actual   :5040
        //Es wird außerdem aufgedröselt, was genau nicht funktioniert hat:
        //1 test completed, 1 failed
        //Und ich kann auf einer HTML-Seite noch mal genau anschauen, was passiert ist.
    }

    //Das ist erst der erste Schritt. Wie ich es bei meinen Notizen bereits schrieb, werden mehrere Datenpunkte getestet:
    //Irgendeine Zahl mittendrin, innerhalb der äußersten Grenzen und ein Stückchen außerhalb. Das fehlt hier noch.

//WICHTIG: Im Falle von Tests kann ich tatsächlich jede Testmethode separat abspielen lassen, ohne dass auch die anderen ausgeführt werden.

    @Test
    public void faktorial1TestZero() {
        // Diese Methode testet: Was, wenn l=0
        // Prepare - ich muss bei dieser konkreten Klasse nichts vorbereiten, aber bei anderen schon.

        // Test
        long l = AufgabePrimitiveDateitypen.faktorial1(0);
        //Selbe Klasse: AufgabePrimitiveDateitypen. Selbe Methode: faktorial1.

        // Restore (Optional)
        // Hier wird nichts überschrieben, also muss ich auch nichts wiederherstellen.

        // Evaluate
        assertEquals(1, l);
        //Alles tutti.
        //Nun machen wir absichtlich eine falsche Eingabe, um die Ausgabe anzugucken:

        assertEquals(502454523, l);
//        //Über der Konsolenausgabe steht nun in roter Schrift und mit einem gelben Button "Tests faild: 1".
////        Expected :502454523
////        Actual   :1
//        //Es wird außerdem aufgedröselt, was genau nicht funktioniert hat:
//        //1 test completed, 1 failed
//        //Und ich kann auf einer HTML-Seite noch mal genau anschauen, was passiert ist.
    }

    //Und nun: Zahl kleiner 0!

    @Test
    public void faktorial1TestBelowZero(){
        // Prepare
        // Test
        RuntimeException rte = assertThrows(RuntimeException.class,
                () -> AufgabePrimitiveDateitypen.faktorial1(-1));
        //Im Prinzip rechne ich bei diesem Wert ja damit, dass eine Exception passiert. Also wird die direkt gefangen.
//Das passiert allerdings bei "meinem" Code nicht, weil anders als bei Gyula mein Originalcode gar nicht die negativen Werte abfängt.
        //UPS.

        //Zwischenschritt: Gucken, was passiert.
        //Ich habe geguckt, was passiert, wenn ich in eine der anderen Fehlertest-Dingsis eine -1 schreibe. Es passiert Armageddon.
        //Fazit für mich: Ich sollte meinen Originalcode anpassen.
        //Im Prinzip ist genau das passiert, wofür Tests da sind - ich habe festgestellt, dass mein Originalcode nicht tut, was er soll.
        //Ich passe den Originalcode an.

        //Der Originalcode ward angepasst. Probieren wir das mit dem Evaluate noch mal.

        //Expected :true
        //Actual   :false
        //Fehlersuche: Ich hatte ursprünglich bei    assertTrue(rte.getMessage().contains("")); eine andere Fehlermeldung als in der Originalmethode.
        //Die Fehlermeldung muss EXAKT gleich sein. Dann ist der Test erfolgreich.

        // Evaluate
        assertTrue(rte.getMessage().contains("Es ist ein Fehler aufgetreten!"));

    }

    //Jetzt haben wir: Exakt Mindestwert und "unter Mindestwert".
    //Als nächstes: Maximalwert. Das ist einfach. Das Selbe wie bei der beliebigen Zahl und bei der 0, aber in Grün.

    @Test
    public void faktorial1TestMax() {
        // Diese Methode testet: Was, wenn l=20
        // Prepare - ich muss bei dieser konkreten Klasse nichts vorbereiten, aber bei anderen schon.

        // Test
        long l = AufgabePrimitiveDateitypen.faktorial1(20);
        //Selbe Klasse: AufgabePrimitiveDateitypen. Selbe Methode: faktorial1.

        // Restore (Optional)
        // Hier wird nichts überschrieben, also muss ich auch nichts wiederherstellen.

        // Evaluate
        assertEquals(2.43290200817664e18, l);
        //Die Schreibweise ist wichtig. Andere Schreibweise (2432902008176640000) wirft direkt einen Fehler in der Eingabe.
        //Aber mit der Schreibweise, erneut: Alles tutti.
        //Nun machen wir absichtlich eine falsche Eingabe, um die Ausgabe anzugucken:

        //assertEquals(502454523, l);
        //Expected :502454523
        //Actual   :2432902008176640000
        //Kommentieren wir das mal wieder aus.
    }

    //Last but not least ... 21.
    //Da ich nun den Code im Original analog zu Gyulas Vorbildcode ausgebaut habe, müsste hierbei als Ausgabe -1 herauskommen.

    @Test
    public void faktorial1TestHypermax(){
        // Prepare
        // Test
        long l = AufgabePrimitiveDateitypen.faktorial1(21);
        // Restore (opt)
        // Evaluate
        assertEquals(-1, l);

        //Und auch hier zum Testen noch mal Unsinn:
        //assertEquals("a", l);
        //Fairerweise kommt hier sogar per Mouse-Over, dass "a" nicht das Gleiche sein KANN wie -1. Aber das habe ich absichtlich ignoriert.
        //Expected :a
        //Actual   :-1

    }



}
